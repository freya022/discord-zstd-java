import com.github.luben.zstd.ZstdOutputStream
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.gradle.work.DisableCachingByDefault
import java.io.ByteArrayOutputStream
import java.nio.file.Files
import java.nio.file.Path
import java.util.*
import java.util.zip.Inflater
import java.util.zip.InflaterOutputStream
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import kotlin.io.path.*
import kotlin.streams.asSequence

private const val rootDirName = "gateway-chunks-zlib"

private val chunkFolderRegex = Regex("""shard-(\d+)""")
private val chunkFileRegex = Regex("""chunk-(\d+)\.bin.zlib""")

@DisableCachingByDefault
abstract class TestDataGeneratorTask : DefaultTask() {

    @InputDirectory
    val inputFolder: Path = project.rootDir.toPath().resolve(rootDirName)

    @OutputDirectory
    val rootOutputFolder: Path = project.project(":test-data").projectDir.toPath().resolve("src/main/resources/chunks")

    @TaskAction
    fun generate() {
        require(inputFolder.exists()) {
            "Input folder name must exist as generated by the JDA data capture ('$rootDirName')"
        }

        require(rootOutputFolder.parent.exists())
        require(rootOutputFolder.notExists() || rootOutputFolder.walk().none()) { "The directory at ${rootOutputFolder.absolutePathString()} must be deleted first" }
        if (rootOutputFolder.notExists()) {
            rootOutputFolder.createDirectory()
        }

        Files.walk(inputFolder, 1)
            .filter { it != inputFolder }
            .asSequence()
            .onEach { chunkFolder ->
                require(chunkFolder.name.matches(chunkFolderRegex)) {
                    "Chunk folder name must match ${chunkFolderRegex.pattern}"
                }
            }
            .sortedBy { chunkFolder ->
                val shardId = chunkFolderRegex.matchEntire(chunkFolder.name)!!.groupValues[1]
                shardId.toInt()
            }
            .forEach { chunkFolder ->
                processChunkFolder(chunkFolder)
            }

        rootOutputFolder.resolve("Key.bin").writeBytes(Encryptor.base64Key)
        rootOutputFolder.resolve("Parameters.bin").writeBytes(Encryptor.base64Parameters)
    }

    private fun processChunkFolder(chunkFolder: Path) {
        val chunkOutputFolder = rootOutputFolder.resolve(chunkFolder.name)
        chunkOutputFolder.createDirectory()

        val inflater = Inflater()
        val compressedStream = ByteArrayOutputStream()
        val zstdStream = ZstdOutputStream(compressedStream).apply {
            // These are the parameters Discord uses
            setLevel(7)
            setChainLog(15)
            setHashLog(15)
            setWindowLog(16)
        }

        context(chunkOutputFolder, inflater, compressedStream, zstdStream) {
            Files.walk(chunkFolder, 1)
                .filter { it != chunkFolder }
                .asSequence()
                .onEach { chunkFile ->
                    require(chunkFile.name.matches(chunkFileRegex)) {
                        "Chunk file name must match ${chunkFileRegex.pattern}"
                    }
                }
                .sortedBy { chunkFile ->
                    val chunkNumber = chunkFileRegex.matchEntire(chunkFile.name)!!.groupValues[1]
                    chunkNumber.toInt()
                }
                .forEach { chunkFile ->
                    processChunkFile(chunkFile)
                }
        }
    }

    context(chunkOutputFolder: Path, inflater: Inflater, compressedStream: ByteArrayOutputStream, zstdStream: ZstdOutputStream)
    private fun processChunkFile(chunkFile: Path) {
        val zlibCompressedChunk = chunkFile.readBytes()
        val decompressedChunk = decompressChunk(zlibCompressedChunk)
        val zstdCompressedChunk = compressChunkToZstd(decompressedChunk)

        val decompressedPath = chunkOutputFolder.resolve(chunkFile.nameWithoutExtension)
        val zlibCompressedPath = chunkOutputFolder.resolve("${chunkFile.nameWithoutExtension}.zlib")
        val zstdCompressedPath = chunkOutputFolder.resolve("${chunkFile.nameWithoutExtension}.zstd")

        decompressedPath.writeBytes(Encryptor.encrypt(decompressedChunk))
        zlibCompressedPath.writeBytes(Encryptor.encrypt(zlibCompressedChunk))
        zstdCompressedPath.writeBytes(Encryptor.encrypt(zstdCompressedChunk))
    }

    context(inflater: Inflater)
    private fun decompressChunk(zlibCompressedChunk: ByteArray): ByteArray {
        val decompressedStream = ByteArrayOutputStream()
        InflaterOutputStream(decompressedStream, inflater).use { inflaterStream ->
            inflaterStream.write(zlibCompressedChunk)
        }
        return decompressedStream.toByteArray()
    }

    // zstd-jni doesn't support reusing the streaming compression context...
    // so we have to keep the output stream across chunks
    context(compressedStream: ByteArrayOutputStream, zstdStream: ZstdOutputStream)
    private fun compressChunkToZstd(decompressedChunk: ByteArray): ByteArray {
        compressedStream.reset()
        zstdStream.write(decompressedChunk)
        zstdStream.flush()
        return compressedStream.toByteArray()
    }

    private object Encryptor {
        private val key: SecretKey = KeyGenerator.getInstance("AES").generateKey()
        private val cipher: Cipher = Cipher.getInstance("AES/CBC/PKCS5Padding").apply {
            init(Cipher.ENCRYPT_MODE, key)
        }

        val base64Key: ByteArray
            get() = Base64.getEncoder().encode(key.encoded)
        val base64Parameters: ByteArray
            get() = Base64.getEncoder().encode(cipher.getParameters().getEncoded())

        fun encrypt(bytes: ByteArray): ByteArray {
            return cipher.doFinal(bytes)
        }
    }
}
